---
layout: documentation
title: Minor CPU Model
doc: gem5 documentation
parent: cpu_models
permalink: /documentation/general_docs/cpu_models/minor_cpu
author: Andrew Bardsley
---

Minor CPU Model

This document contains a description of the structure and function of the
[Minor](http://doxygen.gem5.org/release/current/namespaceMinor.html) gem5 in-order
processor model.

It is recommended reading for anyone who wants to understand
[Minor](http://doxygen.gem5.org/release/current/namespaceMinor.html)'s internal
organisation, design decisions, C++ implementation and Python configuration. A
familiarity with gem5 and some of its internal structures is assumed. This
document is meant to be read alongside the
[Minor](http://doxygen.gem5.org/release/current/namespaceMinor.html) source code
and to explain its general structure without being too slavish about naming
every function and data type.

## What is Minor?

[Minor](http://doxygen.gem5.org/release/current/namespaceMinor.html) is an in-order
processor model with a fixed pipeline but configurable data structures and
execute behaviour. It is intended to be used to model processors with strict
in-order execution behaviour and allows visualisation of an instruction's
position in the pipeline through the MinorTrace/minorview.py format/tool. The
intention is to provide a framework for micro-architecturally correlating the
model with a particular, chosen processor with similar capabilities.

## Design Philosophy

### Multithreading

The model isn't currently capable of multithreading but there are THREAD
comments in key places where stage data needs to be arrayed to support
multithreading.

### Data structures

Decorating data structures with large amounts of life-cycle information is
avoided. Only instructions
([MinorDynInst](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html)) contain a
significant proportion of their data content whose values are not set at
construction.

All internal structures have fixed sizes on construction. Data held in queues
and FIFOs ([MinorBuffer](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorBuffer.html),
[FUPipeline](
http://doxygen.gem5.org/release/current/classMinor_1_1FUPipeline.html)) should have
a [BubbleIF](http://doxygen.gem5.org/release/current/classMinor_1_1BubbleIF.html)
interface to allow a distinct 'bubble'/no data value option for each type.

Inter-stage 'struct' data is packaged in structures which are passed by value.
Only [MinorDynInst](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html), the line
data in [ForwardLineData](
http://doxygen.gem5.org/release/current/classMinorCPU.html#a36a7ec6a8c5a6d27fd013d8b0238029d)
and the memory-interfacing objects [Fetch1::FetchRequest](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1_1_1FetchRequest.html)
and [LSQ::LSQRequest](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ_1_1LSQRequest.html) are
`::new` allocated while running the model.

## Model structure

Objects of class [MinorCPU](
http://doxygen.gem5.org/release/current/classMinorCPU.html) are provided by the
model to gem5. [MinorCPU](
http://doxygen.gem5.org/release/current/classMinorCPU.html) implements the
interfaces of (cpu.hh) and can provide data and instruction interfaces for
connection to a cache system. The model is configured in a similar way to other
gem5 models through Python. That configuration is passed on to
[MinorCPU::pipeline](
http://doxygen.gem5.org/release/current/classMinorCPU.html#a36a7ec6a8c5a6d27fd013d8b0238029d)
(of class [Pipeline](
http://doxygen.gem5.org/release/current/classMinor_1_1Pipeline.html)) which
actually implements the processor pipeline.

The hierarchy of major unit ownership from [MinorCPU](
http://doxygen.gem5.org/release/current/classMinorCPU.html) down looks like this:

```
MinorCPU
--- Pipeline - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism.
--- --- Fetch1 - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface).
--- --- --- Fetch1::IcachePort - interface to the I-cache from Fetch1.
--- --- Fetch2 - line to instruction decomposition.
--- --- Decode - instruction to micro-op decomposition.
--- --- Execute - instruction execution and data memory interface.
--- --- --- LSQ - load store queue for memory ref. instructions.
--- --- --- LSQ::DcachePort - interface to the D-ache from Execute.
```

## Key data structures

### Instruction and line identity: Instld (`dyn_inst.hh`)

```
- T/S.P/L - for fetched cache lines
- T/S.P/L/F - for instructions before Decode
- T/S.P/L/F.E - for instructions from Decode onwards
```

for example:

```
- 0/10.12/5/6.7
```

[InstId](http://doxygen.gem5.org/release/current/classMinor_1_1InstId.html) fields
are:

|Field|Symbol|Generated by|Checked by|Function|
|:----|:-----|:-----------|:---------|:-------|
|InstId::threadId|T|[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) | Everywhere the thread number is needed| Thread number (currently always 0).
|InstId::streamSeqNum|S|[Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) | Fetch1, Fetch2, Execute (to discard lines/insts) | Stream sequence number as chosen by Execute. Stream sequence numbers change after changes of PC (branches, exceptions) in Execue and are used to separate pre and post brnach instrucion streams.|
|InstId::predictionSeqNum|[Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html)| Fetch2 (while discarding lines after prediction)| Prediction sequence numbers represent branch prediction decisions. This is used by Fetch2 to mark lines/instructions/ according to the last followed branch prediction made by Fetch2. Fetch2 can signal to Fetch1 that it should change its fetch address and mark lines with a new prediction sequence number (which it will only do if the stream sequence number Fetch1 expects matches that of the request).
|InstId::lineSeqNum|[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html)| (just for debugging) | Line fetch sequence number of this cache line or the line this instruction was extracted from.|
|InstId::fetchSeqNum|[Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) | Fetch2 (as the inst. sequence number for branches) | Instruction fetch order assigned by Fetch2 when lines are decomposed into instructions.|
|InstId::execSeqNum|[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html)|Execute (to check instruction identify in queues/FUs/LSQ| Instruction order after micro-op decomposition|

The sequence number fields are all independent of each other and although, for
instance, [InstId::execSeqNum](
http://doxygen.gem5.org/release/current/classMinor_1_1InstId.html#a064b0e4480268559e68510311be2a9b0)
for an instruction will always be >= [InstId::fetchSeqNum](
http://doxygen.gem5.org/release/current/classMinor_1_1InstId.html#a06677e68051a2a52f384e55e9368e33d),
the comparison is not useful.

The originating stage of each sequence number field keeps a counter for that
field which can be incremented in order to generate new, unique numbers.


### Instructi ns: MinorDynInst (`dyn_inst.hh`)

[MinorDynInst](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html) represents
an instruction's progression through the pipeline. An instruction can be three
things:

|Things                |Predicate                                                                                                                         |Explanation|
|:---------------------|:---------------------------------------------------------------------------------------------------------------------------------|:----------|
|A bubble              |[MinorDynInst::isBubble()](http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#a24e835fa495026ca63ffec43ee9cc07e) | no instruction at all, just a space-filler|
|A fault               |[MinorDynInst::isFault()](http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#a24029f3cd1835928d572737a548a824e)  | a fault to pass down the pipeline in an insturction's clothing|
|A decoded instruction |[MinorDynInst::isInst()](http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#adc55cdcf9f7c6588bb27eddb4c7fe38e)   | instructions are actually passed to the gem5 decoder in Fetch2 and so are created fully decoded. MinorDynInst::staticInst is the decoded instruction form. |

Instructions are reference counted using the gem5 [RefCountingPtr](
http://doxygen.gem5.org/release/current/classRefCountingPtr.html) 
([base/refcnt.hh](http://doxygen.gem5.org/release/current/refcnt_8hh.html))
wrapper. They therefore usually appear as MinorDynInstPtr in code. Note that as
[RefCountingPtr](http://doxygen.gem5.org/release/current/classRefCountingPtr.html)
initialises as nullptr rather than an object that supports
[BubbleIF::isBubble](
http://doxygen.gem5.org/release/current/classMinor_1_1BubbleIF.html#a7ce121301dba2e89b94235d96bf339ae)
passing raw MinorDynInstPtrs to [Queues](
http://doxygen.gem5.org/release/current/classMinor_1_1Queue.html) and other similar
structures from stage.hh without boxing is dangerous.

### ForwardLineData (`pipe_data.hh`)

ForwardLineData is used to pass cache lines from Fetch1 to Fetch2. Like
MinorDynInsts, they can be bubbles ([ForwardLineData::isBubble()](
http://doxygen.gem5.org/release/current/classMinor_1_1ForwardLineData.html#a46789690719acf167be0a57c9d7d4f8f)),
fault-carrying or can contain a line (partial line) fetched by Fetch1. The data
carried by ForwardLineData is owned by a Packet object returned from memory and
is explicitly memory managed and do must be deleted once processed (by Fetch2
deleting the Packet).

### ForwardInstData (`pipe_data.hh`)

ForwardInstData can contain up to [ForwardInstData::width()](
http://doxygen.gem5.org/release/current/classMinor_1_1ForwardInstData.html#ad5db21f655f2f1dfff69e6f6d5cc606e)
instructions in its [ForwardInstData::insts](
http://doxygen.gem5.org/release/current/classMinor_1_1ForwardInstData.html#ab54a61c683376aaf5a12ea19ab758340)
vector. This structure is used to carry instructions between Fetch2, Decode and
Execute and to store input buffer vectors in Decode and Execute.

### Fetch1::FetchRequest (`fetch1.hh`)

FetchRequests represent I-cache line fetch requests. The are used in the memory
queues of Fetch1 and are pushed into/popped from [Packet::senderState](
http://doxygen.gem5.org/release/current/classPacket.html#ad1dd4fa4370e508806fe4a8253a0ad12)
while traversing the memory system.

FetchRequests contain a memory system Request ([mem/request.hh](
http://doxygen.gem5.org/release/current/request_8hh.html)) for that fetch access, a
packet (Packet, [mem/packet.hh](
http://doxygen.gem5.org/release/current/packet_8hh.html)), if the request gets to
memory, and a fault field that can be populated with a TLB-sourced prefetch
fault (if any).

### LSQ::LSQRequest (`execute.hh`)

LSQRequests are similar to FetchRequests but for D-cache accesses. They carry
the instruction associated with a memory access.

## The pipeline

```
------------------------------------------------------------------------------
    Key:

    [] : inter-stage BufferBuffer
    ,--.
    |  | : pipeline stage
    `--'
    ---> : forward communication
    <--- : backward communication

    rv : reservation information for input buffers

                ,------.     ,------.     ,------.     ,-------.
 (from  --[]-v->|Fetch1|-[]->|Fetch2|-[]->|Decode|-[]->|Execute|--> (to Fetch1
 Execute)    |  |      |<-[]-|      |<-rv-|      |<-rv-|       |     & Fetch2)
             |  `------'<-rv-|      |     |      |     |       |
             `-------------->|      |     |      |     |       |
                             `------'     `------'     `-------'
------------------------------------------------------------------------------
```

The four pipeline stages are connected together by [MinorBuffer](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorBuffer.html) FIFO
(stage.hh, derived ultimately from [TimeBuffer](
http://doxygen.gem5.org/release/current/classTimeBuffer.html)) structures which
allow inter-stage delays to be modelled. There is a [MinorBuffers](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorBuffer.html) between
adjacent stages in the forward direction (for example: passing lines from
Fetch1 to Fetch2) and, between Fetch2 and Fetch1, a buffer in the backwards
direction carrying branch predictions.

Stages Fetch2, Decode and Execute have input buffers which, each cycle, can
accept input data from the previous stage and can hold that data if the stage
is not ready to process it. Input buffers store data in the same form as it is
received and so Decode and Execute's input buffers contain the output
instruction vector ([ForwardInstData](
http://doxygen.gem5.org/release/current/classMinor_1_1ForwardInstData.html)
([pipe_data.hh](http://doxygen.gem5.org/release/current/pipe__data_8hh.html))) from
their previous stages with the instructions and bubbles in the same positions
as a single buffer entry.

Stage input buffers provide a [Reservable](
http://doxygen.gem5.org/release/current/classMinor_1_1Reservable.html) (stage.hh)
interface to their previous stages, to allow slots to be reserved in their
input buffers, and communicate their input buffer occupancy backwards to allow
the previous stage to plan whether it should make an output in a given cycle.

### Event handling: MinorActivityRecorder (`activity.hh`, `pipeline.hh`)

Minor is essentially a cycle-callable model with some ability to skip cycles
based on pipeline activity. External events are mostly received by callbacks
(e.g. [Fetch1::IcachePort::recvTimingResp](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1_1_1IcachePort.html#aec62b3d89dfe61e8528cdcdf3729eeab))
and cause the pipeline to be woken up to service advancing request queues.

[Ticked](http://doxygen.gem5.org/release/current/classTicked.html) (sim/ticked.hh)
is a base class bringing together an evaluate member function and a provided
[SimObject](http://doxygen.gem5.org/release/current/classSimObject.html). It
provides a [Ticked::start](
http://doxygen.gem5.org/release/current/classTicked.html#a798d1e248c27161de6eb2bc6fef5e425)/stop
interface to start and pause clock events from being periodically issued.
[Pipeline](http://doxygen.gem5.org/release/current/classMinor_1_1Pipeline.html) is
a derived class of Ticked.

During evaluate calls, stages can signal that they still have work to do in the
next cycle by calling either [MinorCPU::activityRecorder](
http://doxygen.gem5.org/release/current/classMinorCPU.html#ae3b03c96ee234e2c5c6c68f4567245a7)->activity()
(for non-callable related activity) or MinorCPU::wakeupOnEvent(<stageId>) (for
stage callback-related 'wakeup' activity).

[Pipeline::evaluate](
http://doxygen.gem5.org/release/current/classMinor_1_1Pipeline.html#af07fdce00c8937e9de5b6450a1cd62bf)
contains calls to evaluate for each unit and a test for pipeline idling which
can turns off the clock tick if no unit has signalled that it may become active
next cycle.

Within Pipeline ([pipeline.hh](
http://doxygen.gem5.org/release/current/pipeline_8hh.html)), the stages are
evaluated in reverse order (and so will ::evaluate in reverse order) and their
backwards data can be read immediately after being written in each cycle
allowing output decisions to be 'perfect' (allowing synchronous stalling of the
whole pipeline). Branch predictions from Fetch2 to Fetch1 can also be
transported in 0 cycles making fetch1ToFetch2BackwardDelay the only
configurable delay which can be set as low as 0 cycles.

The [MinorCPU::activateContext](
http://doxygen.gem5.org/release/current/classMinorCPU.html#a854596342bfb9dd889437e494c4ddb27)
and [MinorCPU::suspendContext](
http://doxygen.gem5.org/release/current/classMinorCPU.html#ae6aa9b1bb798d8938f0b35e11d9e68b8)
interface can be called to start and pause threads (threads in the MT sense)
and to start and pause the pipeline. Executing instructions can call this
interface (indirectly through the ThreadContext) to idle the CPU/their threads.

### Each pipeline stage

In general, the behaviour of a stage (each cycle) is:

```
    evaluate:
        push input to inputBuffer
        setup references to input/output data slots

        do 'every cycle' 'step' tasks

        if there is input and there is space in the next stage:
            process and generate a new output
            maybe re-activate the stage

        send backwards data

        if the stage generated output to the following FIFO:
            signal pipe activity

        if the stage has more processable input and space in the next stage:
            re-activate the stage for the next cycle

        commit the push to the inputBuffer if that data hasn't all been used
```

The Execute stage differs from this model as its forward output (branch) data
is unconditionally sent to Fetch1 and Fetch2. To allow this behaviour, Fetch1
and Fetch2 must be unconditionally receptive to that data.

### Fetch1 stage

[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) is
responsible for fetching cache lines or partial cache lines from the I-cache
and passing them on to [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) to be decomposed
into instructions. It can receive 'change of stream' indications from both
[Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) and
[Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) to
signal that it should change its internal fetch address and tag newly fetched
lines with new stream or prediction sequence numbers. When both Execute and
[Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) signal
changes of stream at the same time, [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) takes
[Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html)'s
change.

Every line issued by [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) will bear a
unique line sequence number which can be used for debugging stream changes.

When fetching from the I-cache, [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html)  will ask for
data from the current fetch address (Fetch1::pc) up to the end of the 'data
snap' size set in the parameter fetch1LineSnapWidth. Subsequent autonomous line
fetches will fetch whole lines at a snap boundary and of size fetch1LineWidth.

[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) will
only initiate a memory fetch if it can reserve space in [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) input buffer.
That input buffer serves an the fetch queue/LFL for the system.

[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html)
contains two queues: requests and transfers to handle the stages of translating
the address of a line fetch (via the TLB) and accommodating the
request/response of fetches to/from memory.

Fetch requests from [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) are pushed into
the requests queue as newly allocated FetchRequest objects once they have been
sent to the ITLB with a call to itb->translateTiming.

A response from the TLB moves the request from the requests queue to the
transfers queue. If there is more than one entry in each queue, it is possible
to get a TLB response for request which is not at the head of the requests
queue. In that case, the TLB response is marked up as a state change to
Translated in the request object, and advancing the request to transfers (and
the memory system) is left to calls to [Fetch1::stepQueues](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html#ac143710b93ec9f55bfc3e2882ef2fe4c)
which is called in the cycle following any event is received.

[Fetch1::tryToSendToTransfers](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html#a9ace21e8131caf360190ea876cfa2934)
---
layout: documentation
title: Execution Basics
doc: gem5 documentation
parent: cpu_models
permalink: /documentation/general_docs/cpu_models/execution_basics
---

is responsible for moving requests between the two queues and issuing requests
to memory. Failed TLB lookups (prefetch aborts) continue to occupy space in the
queues until they are recovered at the head of transfers.

Responses from memory change the request object state to Complete and
[Fetch1::evaluate](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html#a68a0a88ce6ee3dd170c977318cfb4ca9)
can pick up response data, package it in the [ForwardLineData](
http://doxygen.gem5.org/release/current/classMinor_1_1ForwardLineData.html) object,
and forward it to [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html)'s input buffer.

As space is always reserved in [Fetch2::inputBuffer](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html#afdaa27275e2f605d9aaa637e8c39f96d),
setting the input buffer's size to 1 results in non-prefetching behaviour.

When a change of stream occurs, translated requests queue members and completed
transfers queue members can be unconditionally discarded to make way for new
transfers.

### Fetch2 stage

Fetch2 receives a line from Fetch1 into its input buffer. The data in the head
line in that buffer is iterated over and separated into individual instructions
which are packed into a vector of instructions which can be passed to
[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html).
Packing instructions can be aborted early if a fault is found in either the
input line as a whole or a decomposed instruction.

#### Branch prediction

Fetch2 contains the branch prediction mechanism. This is a wrapper around the branch predictor interface provided by gem5 (cpu/pred/...).

Branches are predicted for any control instructions found. If prediction is
attempted for an instruction, the [MinorDynInst::triedToPredict](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#a905b0516019ae7f47b5795ceda33f5cd)
flag is set on that instruction.

When a branch is predicted to take, the [MinorDynInst::predictedTaken](http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#aa57659ef9d30162ddcf10fcb0f3963ac) flag is set and [MinorDynInst::predictedTarget](http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#a5eaf9547bcaefa2c0fd37f32c828691b) is set to the predicted target PC value. The predicted branch instruction is then packed into Fetch2's output vector, the prediction sequence number is incremented, and the branch is communicated to Fetch1.

After signalling a prediction, Fetch2 will discard its input buffer contents
and will reject any new lines which have the same stream sequence number as
that branch but have a different prediction sequence number. This allows
following sequentially fetched lines to be rejected without ignoring new lines
generated by a change of stream indicated from a 'real' branch from Execute
(which will have a new stream sequence number).

The program counter value provided to Fetch2 by Fetch1 packets is only updated
when there is a change of stream. Fetch2::havePC indicates whether the PC will
be picked up from the next processed input line. Fetch2::havePC is necessary to
allow line-wrapping instructions to be tracked through decode.

Branches (and instructions predicted to branch) which are processed by Execute
will generate BranchData ([pipe_data.hh](
http://doxygen.gem5.org/release/current/pipe__data_8hh.html)) data explaining the
outcome of the branch which is sent forwards to Fetch1 and Fetch2. Fetch1 uses
this data to change stream (and update its stream sequence number and address
for new lines). Fetch2 uses it to update the branch predictor. Minor does not
communicate branch data to the branch predictor for instructions which are
discarded on the way to commit.

BranchData::BranchReason ([pipe_data.hh](
http://doxygen.gem5.org/release/current/pipe__data_8hh.html)) encodes the possible
branch scenarios:


|Branch enum val.          | In Execute                                                   | Fetch1 reaction                                                        | Fetch2 reaction             |
|:-------------------------|:-------------------------------------------------------------|:-----------------------------------------------------------------------|:----------------------------|
|No Branch                 |(output bubble data)                                          |-                                                                       |-                            |
|CorrectlyPredictedBranch  |Predicted, taken                                              |-                                                                       |Update BP as taken branch    |
|UnpredictedBranch         |Not predicted, taken and was taken                            |New stream                                                              |Update BP as taken branch    |
|BadlyPredictedBranch      |Predicted, not taken                                          |New stream to restore to old Inst. source                               |Update BP as not taken branch|
|BadlyPredictedBranchTarget|Predicted, taken, but to a different target than predicted one|New stream                                                              |Update BTB to new target     |
|SuspendThread             |Hint to suspend fetch                                         |Suspend fetch for this thread (branch to next inst. as wakeup fetch addr|-                            |
|Interrupt                 |Interrupt detected                                            |New stream                                                              |-                            |


---
layout: documentation
title: Execution Basics
doc: gem5 documentation
parent: cpu_models
permalink: /documentation/general_docs/cpu_models/execution_basics
---

### Decode Stage

[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html) takes a
vector of instructions from [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) (via its input
buffer) and decomposes those instructions into micro-ops (if necessary) and
packs them into its output instruction vector.

The parameter executeInputWidth sets the number of instructions which can be
packed into the output per cycle. If the parameter decodeCycleInput is true,
[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html) can try
to take instructions from more than one entry in its input buffer per cycle.

### Execute Stage

Execute provides all the instruction execution and memory access mechanisms. An
instructions passage through Execute can take multiple cycles with its precise
timing modelled by a functional unit pipeline FIFO.

A vector of instructions (possibly including fault 'instructions') is provided
to Execute by Decode and can be queued in the Execute input buffer before being
issued. Setting the parameter executeCycleInput allows execute to examine more
than one input buffer entry (more than one instruction vector). The number of
instructions in the input vector can be set with executeInputWidth and the
depth of the input buffer can be set with parameter executeInputBufferSize.

#### Functional units

The Execute stage contains pipelines for each functional unit comprising the
computational core of the CPU. Functional units are configured via the
executeFuncUnits parameter. Each functional unit has a number of instruction
classes it supports, a stated delay between instruction issues, and a delay
from instruction issue to (possible) commit and an optional timing annotation
capable of more complicated timing.

Each active cycle, [Execute::evaluate](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#a2d6ca9a694bf99ef82da7759cba8c3da)
performs this action:

```
    Execute::evaluate:
        push input to inputBuffer
        setup references to input/output data slots and branch output slot

        step D-cache interface queues (similar to Fetch1)

        if interrupt posted:
            take interrupt (signalling branch to Fetch1/Fetch2)
        else
            commit instructions
            issue new instructions

        advance functional unit pipelines

        reactivate Execute if the unit is still active

        commit the push to the inputBuffer if that data hasn't all been used
```

#### Functional unit FIFOs



Functional units are implemented as SelfStallingPipelines (stage.hh). These are
[TimeBuffer](http://doxygen.gem5.org/release/current/classTimeBuffer.html) FIFOs
with two distinct 'push' and 'pop' wires. They respond to
[SelfStallingPipeline::advance](
http://doxygen.gem5.org/release/current/classMinor_1_1SelfStallingPipeline.html#ad933640bc6aab559c009302e478c3768)
in the same way as TimeBuffers unless there is data at the far, 'pop', end of
the FIFO. A 'stalled' flag is provided for signalling stalling and to allow a
stall to be cleared. The intention is to provide a pipeline for each functional
unit which will never advance an instruction out of that pipeline until it has
been processed and the pipeline is explicitly unstalled.

The actions 'issue', 'commit', and 'advance' act on the functional units.

#### Issue

Issuing instructions involves iterating over both the input buffer instructions
and the heads of the functional units to try and issue instructions in order.
The number of instructions which can be issued each cycle is limited by the
parameter executeIssueLimit, how executeCycleInput is set, the availability of
---
layout: documentation
title: Execution Basics
doc: gem5 documentation
parent: cpu_models
permalink: /documentation/general_docs/cpu_models/execution_basics
---

pipeline space and the policy used to choose a pipeline in which the
instruction can be issued.

At present, the only issue policy is strict round-robin visiting of each
pipeline with the given instructions in sequence. For greater flexibility,
better (and more specific policies) will need to be possible.

Memory operation instructions traverse their functional units to perform their
EA calculations. On 'commit', the [ExecContext](
http://doxygen.gem5.org/release/current/classMinor_1_1ExecContext.html)::initiateAcc
execution phase is performed and any memory access is issued (via.
ExecContext::{read,write}Mem calling [LSQ::pushRequest](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html#a18594a4baa4eef7bfc3be45c03f4d544))
to the [LSQ](http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html).

Note that faults are issued as if they are instructions and can (currently) be
issued to any functional unit.

Every issued instruction is also pushed into the Execute::inFlightInsts queue.
Memory ref. instructions are pushing into Execute::inFUMemInsts queue.

#### Commit

Instructions are committed by examining the head of the Execute::inFlightInsts
queue (which is decorated with the functional unit number to which the
instruction was issued). Instructions which can then be found in their
functional units are executed and popped from Execute::inFlightInsts.

Memory operation instructions are committed into the memory queues (as
described above) and exit their functional unit pipeline but are not popped
from the Execute::inFlightInsts queue. The Execute::inFUMemInsts queue provides
ordering to memory operations as they pass through the functional units
(maintaining issue order). On entering the LSQ, instructions are popped from
Execute::inFUMemInsts.

If the parameter executeAllowEarlyMemoryIssue is set, memory operations can be
sent from their FU to the LSQ before reaching the head of
Execute::inFlightInsts but after their dependencies are met.
[MinorDynInst::instToWaitFor](
http://doxygen.gem5.org/release/current/classMinor_1_1MinorDynInst.html#ac72a9dcff570bbaf24da9ee74392e6d0)
is marked up with the latest dependent instruction execSeqNum required to be
committed for a memory operation to progress to the LSQ.

Once a memory response is available (by testing the head of
Execute::inFlightInsts against [LSQ::findResponse](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html#a458abe5d220a0f66600bf339bceb2100)),
commit will process that response (ExecContext::completeAcc) and pop the
instruction from Execute::inFlightInsts.

Any branch, fault or interrupt will cause a stream sequence number change and
signal a branch to Fetch1/Fetch2. Only instructions with the current stream
sequence number will be issued and/or committed.

#### Advance

All non-stalled pipeline are advanced and may, thereafter, become stalled.
Potential activity in the next cycle is signalled if there are any instructions
remaining in any pipeline.

#### Scoreboard

The scoreboard ([Scoreboard](
http://doxygen.gem5.org/release/current/classMinor_1_1Scoreboard.html)) is used to
control instruction issue. It contains a count of the number of in flight
instructions which will write each general purpose CPU integer or float
register. Instructions will only be issued where the scoreboard contains a
count of 0 instructions which will write to one of the instructions source
registers.

Once an instruction is issued, the scoreboard counts for each destination
register for an instruction will be incremented.

The estimated delivery time of the instruction's result is marked up in the scoreboard by adding the length of the issued-to FU to the current time. The timings parameter on each FU provides a list of additional rules for calculating the delivery time. These are documented in the parameter comments in MinorCPU.py.

On commit, (for memory operations, memory response commit) the scoreboard counters for an instruction's source registers are decremented. will be decremented.

#### Execute::inFlightInsts

The Execute::inFlightInsts queue will always contain all instructions in flight
in [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) in
the correct issue order. [Execute::issue](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#af0b90170a273f1a0d41f4164ba3fe456)
is the only process which will push an instruction into the queue.
[Execute::commit](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#ac2da0ae4202602ce4ad976f33a004237)
is the only process that can pop an instruction.

#### LSQ

The [LSQ](http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html) can
support multiple outstanding transactions to memory in a number of conservative
cases.

There are three queues to contain requests: requests, transfers and the store
buffer. The requests and transfers queue operate in a similar manner to the
queues in Fetch1. The store buffer is used to decouple the delay of completing
store operations from following loads.

Requests are issued to the DTLB as their instructions leave their functional
unit. At the head of requests, cacheable load requests can be sent to memory
and on to the transfers queue. Cacheable stores will be passed to transfers
unprocessed and progress that queue maintaining order with other transactions.

The conditions in [LSQ::tryToSendToTransfers](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html#a7d7b8ddc7c69fd9eb3b8594fe261d8e8)
dictate when requests can be sent to memory.

All uncacheable transactions, split transactions and locked transactions are
processed in order at the head of requests. Additionally, store results
residing in the store buffer can have their data forwarded to cacheable loads
(removing the need to perform a read from memory) but no cacheable load can be
issue to the transfers queue until that queue's stores have drained into the
store buffer.

At the end of transfers, requests which are [LSQ::LSQRequest::Complete](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ_1_1LSQRequest.html#a429d50f5dd6be4217d5dba93f8c289d3a81b9dbf6670e396d0266949d59b57428)
(are faulting, are cacheable stores, or have been sent to memory and received a
response) can be picked off by Execute and either committed
(ExecContext::completeAcc) and, for stores, be sent to the store buffer.

Barrier instructions do not prevent cacheable loads from progressing to memory
but do cause a stream change which will discard that load. Stores will not be
committed to the store buffer if they are in the shadow of the barrier but
before the new instruction stream has arrived at Execute. As all other memory
transactions are delayed at the end of the requests queue until they are at the
head of Execute::inFlightInsts, they will be discarded by any barrier stream
change.

After commit, [LSQ::BarrierDataRequest](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ_1_1BarrierDataRequest.html)
requests are inserted into the store buffer to track each barrier until all
preceding memory transactions have drained from the store buffer. No further
memory transactions will be issued from the ends of FUs until after the barrier
has drained.

#### Draining

Draining is mostly handled by the [Execute](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) stage. When
initiated by calling [MinorCPU::drain](
http://doxygen.gem5.org/release/current/classMinorCPU.html#a3191c9247cd80dfc603bfcd154cf09a0),
[Pipeline::evaluate](
http://doxygen.gem5.org/release/current/classMinor_1_1Pipeline.html#af07fdce00c8937e9de5b6450a1cd62bf)
checks the draining status of each unit each cycle and keeps the pipeline
active until draining is complete. It is Pipeline that signals the completion
of draining. Execute is triggered by [MinorCPU::drain](
http://doxygen.gem5.org/release/current/classMinorCPU.html#a3191c9247cd80dfc603bfcd154cf09a0)
and starts stepping through its [Execute::DrainState](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40)
state machine, starting from state Execute::NotDraining, in this order:

|State|Meaning|
|[Execute::NotDraining](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40aeecf47987ef0d4aa0a6a59403d085ec9)|Not trying to drain, normal execution|
|[Execute::DrainCurrentInst](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40aec53785380b6256e2baa889739311570)|Draining micro-ops to complete inst.|
|[Execute::DrainHaltFetch](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40a516d421a79c458d376bedeb067fc207f)|Halt fetching instructions|
|[Execute::DrainAllInsts](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40ade3ca2567fed8d893896d71bb95f13ca)|Discarding all instructions presented|

When complete, a drained Execute unit will be in the [Execute::DrainAllInsts](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40ade3ca2567fed8d893896d71bb95f13ca)
state where it will continue to discard instructions but has no knowledge of
the drained state of the rest of the model.

## Debug options

The model provides a number of debug flags which can be passed to gem5 with the
`–debug-flags` option.

The available flags are:

|Debug flag      | Unit which will generate debugging output |
|:---------------|:------------------------------------------|
|Activity        | [Debug](http://doxygen.gem5.org/release/current/namespaceDebug.html) ActivityMonitor actions |
|Branch          | [Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) and [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) branch prediction decisions |
|[MinorCPU](http://doxygen.gem5.org/release/current/classMinorCPU.html)      | CPU global actions such as wakeup/thread suspension |
|[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html) | [Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html) |
|MinorExec       | [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) behaviour |
|Fetch           |[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) and [Fetch2](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) |
|MinorInterrupt  | [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) interrupt handling  |
|MinorMem        | [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) memory interactions |
|MinorScoreboard | [Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) scoreboard activity |
|MinorTrace      | Generate MinorTrace cyclic state trace output (see below) |
|MinorTiming     | MinorTiming instruction timing modification operations    |

The group flag [Minor](http://doxygen.gem5.org/release/current/namespaceMinor.html)
enables all the flags beginning with [Minor](
http://doxygen.gem5.org/release/current/namespaceMinor.html).

## MinorTrace and minorview.py

The debug flag MinorTrace causes cycle-by-cycle state data to be printed which
can then be processed and viewed by the minorview.py tool. This output is very
verbose and so it is recommended it only be used for small examples.

### MinorTrace format

There are three types of line outputted by MinorTrace:

#### MinorTrace - Ticked unit cycle state

For example:

```
 110000: system.cpu.dcachePort: MinorTrace: state=MemoryRunning in_tlb_mem=0/0
```

For each time step, the MinorTrace flag will cause one MinorTrace line to be
printed for every named element in the model.

#### MinorInst - summaries of instructions issued by Decode

[Decode](http://doxygen.gem5.org/release/current/classMinor_1_1Decode.html)

For example:

```
 140000: system.cpu.execute: MinorInst: id=0/1.1/1/1.1 addr=0x5c \
                             inst="  mov r0, #0" class=IntAlu
```

MinorInst lines are currently only generated for instructions which are committed.

#### MinorLine - summaries of line fetches issued by Fetch1

[Fetch1](http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html)

For example:

```
  92000: system.cpu.icachePort: MinorLine: id=0/1.1/1 size=36 \
                                vaddr=0x5c paddr=0x5c
```

### minorview.py

Minorview (util/minorview.py) can be used to visualise the data created by
MinorTrace.

```
usage: minorview.py [-h] [--picture picture-file] [--prefix name]
                   [--start-time time] [--end-time time] [--mini-views]
                   event-file

Minor visualiser

positional arguments:
  event-file

optional arguments:
  -h, --help            show this help message and exit
  --picture picture-file
                        markup file containing blob information (default:
                        <minorview-path>/minor.pic)
  --prefix name         name prefix in trace for CPU to be visualised
                        (default: system.cpu)
  --start-time time     time of first event to load from file
  --end-time time       time of last event to load from file
  --mini-views          show tiny views of the next 10 time steps
```

Raw debugging output can be passed to minorview.py as the event-file. It will
pick out the MinorTrace lines and use other lines where units in the simulation
are named (such as system.cpu.dcachePort in the above example) will appear as
'comments' when units are clicked on the visualiser.

Clicking on a unit which contains instructions or lines will bring up a speech
bubble giving extra information derived from the MinorInst/MinorLine lines.

`–start-time` and `–end-time` allow only sections of debug files to be loaded.

`–prefix` allows the name prefix of the CPU to be inspected to be supplied.
This defaults to `system.cpu`.

In the visualiser, The buttons Start, End, Back, Forward, Play and Stop can be
used to control the displayed simulation time.

The diagonally striped coloured blocks are showing the [InstId](
http://doxygen.gem5.org/release/current/classMinor_1_1InstId.html) of the
instruction or line they represent. Note that lines in [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) and f1ToF2.F
only show the id fields of a line and that instructions in [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html), f2ToD, and
decode.inputBuffer do not yet have execute sequence numbers. The T/S.P/L/F.E
buttons can be used to toggle parts of [InstId](
http://doxygen.gem5.org/release/current/classMinor_1_1InstId.html) on and off to
make it easier to understand the display. Useful combinations are:

|Combination|Reason                                                                                                                      |
|:----------|:---------------------------------------------------------------------------------------------------------------------------|
|E          |just show the final execute sequence number                                                                                 |
|F/E        |show the instruction-related numbers                                                                                        |
|S/P        |show just the stream-related numbers (watch the stream sequence change with branches and not change with predicted branches)|
|S/E        |show instructions and their stream                                                                                          |

The key to the right shows all the displayable colours (some of the colour
choices are quite bad!):

|Symbol |Meaning                                                      |
|:------|:------------------------------------------------------------|
|U      |Uknown data                                                  |
|B      |Blocked stage                                                |
|-      |Bubble                                                       |
|E      |Empty queue slot                                             |
|R      |Reserved queue slot                                          |
|F      |Fault                                                        |
|r      |Read (used as the leftmost stripe on data in the dcachePort) |
|w      |Write " "                                                    |
|0 to 9 |last decimal digit of the corresponding data                 |

```
    ,---------------.         .--------------.  *U
    | |=|->|=|->|=| |         ||=|||->||->|| |  *-  <- Fetch queues/LSQ
    `---------------'         `--------------'  *R
    === ======                                  *w  <- Activity/Stage activity
                              ,--------------.  *1
    ,--.      ,.      ,.      | ============ |  *3  <- Scoreboard
    |  |-\[]-\||-\[]-\||-\[]-\| ============ |  *5  <- Execute::inFlightInsts
    |  | :[] :||-/[]-/||-/[]-/| -. --------  |  *7
    |  |-/[]-/||  ^   ||      |  | --------- |  *9
    |  |      ||  |   ||      |  | ------    |
[]->|  |    ->||  |   ||      |  | ----      |
    |  |<-[]<-||<-+-<-||<-[]<-|  | ------    |->[] <- Execute to Fetch1,
    '--`      `'  ^   `'      | -' ------    |        Fetch2 branch data
             ---. |  ---.     `--------------'
             ---' |  ---'       ^       ^
                  |   ^         |       `------------ Execute
  MinorBuffer ----' input       `-------------------- Execute input buffer
                    buffer
```

Stages show the colours of the instructions currently being
generated/processed.

Forward FIFOs between stages show the data being pushed into them at the
current tick (to the left), the data in transit, and the data available at
their outputs (to the right).

The backwards FIFO between [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) and [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) shows branch
prediction data.

In general, all displayed data is correct at the end of a cycle's activity at
the time indicated but before the inter-stage FIFOs are ticked. Each FIFO has,
therefore an extra slot to show the asserted new input data, and all the data
currently within the FIFO.

Input buffers for each stage are shown below the corresponding stage and show
the contents of those buffers as horizontal strips. Strips marked as reserved
(cyan by default) are reserved to be filled by the previous stage. An input
buffer with all reserved or occupied slots will, therefore, block the previous
stage from generating output.

Fetch queues and [LSQ](
http://doxygen.gem5.org/release/current/classMinor_1_1LSQ.html) show the
lines/instructions in the queues of each interface and show the number of
lines/instructions in TLB and memory in the two striped colours of the top of
their frames.

Inside [Execute](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html), the horizontal
bars represent the individual FU pipelines. The vertical bar to the left is the
input buffer and the bar to the right, the instructions committed this cycle.
The background of [Execute](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) shows
instructions which are being committed this cycle in their original FU pipeline
positions.

The strip at the top of the [Execute](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) block shows the
current streamSeqNum that [Execute](
http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) is committing.
A similar stripe at the top of [Fetch1](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch1.html) shows that
stage's expected streamSeqNum and the stripe at the top of [Fetch2](
http://doxygen.gem5.org/release/current/classMinor_1_1Fetch2.html) shows its
issuing predictionSeqNum.

The scoreboard shows the number of instructions in flight which will commit a
result to the register in the position shown. The scoreboard contains slots for
each integer and floating point register.

The Execute::inFlightInsts queue shows all the instructions in flight in
[Execute](http://doxygen.gem5.org/release/current/classMinor_1_1Execute.html) with
the oldest instruction (the next instruction to be committed) to the right.

`Stage activity` shows the signalled activity (as E/1) for each stage (with CPU
miscellaneous activity to the left)

`Activity` show a count of stage and pipe activity.

### minor.pic format

The minor.pic file (src/minor/minor.pic) describes the layout of the models
blocks on the visualiser. Its format is described in the supplied minor.pic
file.

